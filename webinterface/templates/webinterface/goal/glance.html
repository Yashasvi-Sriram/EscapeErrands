{% extends 'webinterface/base.html' %}
{% block title %}Goals at a Glance{% endblock %}
{% load static %}
{% block extra_headers %}
    {# Vis JS #}
    <script src="{% static 'webinterface/vis.min.js' %}"></script>
    <link type="text/css" rel="stylesheet" href="{% static 'webinterface/vis.min.css' %}"/>
    <link type="text/css" rel="stylesheet" href="{% static 'webinterface/vis-network.min.css' %}"/>
    {# React & babel #}
    <script src="{% static 'webinterface/react/react.js' %}"></script>
    <script src="{% static 'webinterface/react/react-dom.js' %}"></script>
    <script src="{% static 'webinterface/react/babel.js' %}"></script>
    {# Misc #}
    <script src="{% static 'webinterface/cookies.js' %}"></script>
    <script src="{% static 'webinterface/moment.js' %}"></script>
    <script src="{% static 'webinterface/myjs/datetimeconverter.js' %}"></script>
{% endblock %}
{% block css %}
    <style>
        .goal-search-input {
            font-size: x-large !important;
            color: black !important;
            outline: none !important;
            margin-bottom: 0 !important;
            box-shadow: none !important;
            border-bottom: 1px solid black !important;
            width: 90% !important;
            padding-left: 5% !important;
            padding-right: 5% !important;
        }

        .goal-search-app {
            position: fixed;
            top: 0;
            left: 0;
            width: 33%;
            z-index: 999;
            margin: 20px;
            background-color: white;
            border: 2px solid black;
            border-bottom-width: 1px;
            font-family: monospace;
            font-size: large;
            font-weight: bold;
        }

        .goal-search-result:hover {
            background: rgba(63, 63, 63, 0.10);
        }

        .goal-achievement-status:hover {
            cursor: pointer;
        }

        .goal-search-result-set-container {
            height: 90vh;
            overflow-y: auto;
        }

        #goal-canvas-wrapper {
            height: 100vh;
        }

        .goal-canvas-clear-btn {
            position: fixed;
            top: 20px;
            right: 20px;
        }

        .goal-detail-view {
            position: fixed;
            width: 25%;
            background-color: white;
            border: 2px solid black;
            padding: 20px;
            margin: 20px;
            z-index: 1000;
            font-size: large;
            font-weight: bold;
            top: 0;
            right: 0;
        }

        .goal-detail-view-description {
            border: none;
            border-bottom: 1px solid black;
            height: 200px;
            color: black;
            font-size: large;
        }

        .goal-detail-view-description:focus {
            border: 1px solid black;
            outline: none;
        }

        .goal-detail-view-deadline {
            outline: none !important;
            box-shadow: none !important;
            border-bottom: 1px solid black !important;
            color: black;
            font-size: large;
        }

        .goal-detail-view-hide-btn {
            padding: 0;
            position: absolute;
            top: 5px;
            right: 10px;
        }

        .goal-detail-view-update-btn {
            padding: 0;
        }

        .goal-detail-view-deselect-btn {
            padding: 0;
        }

        .goal-detail-view-delete-btn {
            position: absolute;
            right: 20px;
            padding: 0;
        }

        .create-goal-view-toggle-btn {
            position: fixed;
            top: 80px;
            right: 20px;
        }

        .create-goal-view {
            position: fixed;
            width: 25%;
            background-color: white;
            border: 2px solid black;
            padding: 20px;
            margin: 20px;
            z-index: 1000;
            font-size: large !important;
            font-weight: bold !important;
            bottom: 0;
            right: 0;
        }

        .create-goal-view-description {
            color: black !important;
            font-size: large !important;
            border: none !important;
            border-bottom: 1px solid black !important;
            height: 200px !important;
        }

        .create-goal-view-description:focus {
            border: 1px solid black !important;
            outline: none !important;
        }

        .create-goal-view-deadline {
            color: black !important;
            font-size: large !important;
            outline: none !important;
            box-shadow: none !important;
            border-bottom: 1px solid black !important;
        }

        .create-goal-view-hide-btn {
            padding: 0;
            position: absolute;
            top: 5px;
            right: 10px;
        }

        .create-goal-view-submit-btn {
            padding: 0;
        }

    </style>
{% endblock %}
{% block body %}
    <script type="text/babel">
        //
        // todo: react-ify a bit more
        //

        let truncate = function (string, maxLength) {
            let label;
            if (string.length > maxLength) {
                label = string.substring(0, maxLength) + '...';
            }
            else {
                label = string;
            }
            return label;
        };

        /**
         * @propFunctions: onKeyDown, onDoubleClick
         * */
        let GoalSearchInput = React.createClass({
            render: function () {
                return (
                        <label>
                            <input className="goal-search-input"
                                   autoFocus
                                   onKeyDown={this.props.onKeyDown}
                                   onDoubleClick={this.props.onDoubleClick}
                                   title="Search"
                                   type="text"/>
                        </label>
                );
            }
        });

        /**
         * @propFunctions: onDescriptionClick, onDeadlineClick, onAchievementClick
         * */
        let GoalSearchResult = React.createClass({
            render: function () {
                let isAchieved = 'crop_square';
                if (this.props.isAchieved === true)
                    isAchieved = 'done';
                let style = {
                    color: this.props.color,
                };
                let description = this.props.description === '' ? '@no_description' : truncate(this.props.description, this.props.maxDescLength);
                let deadlineRepr = function (deadline) {
                    let momentDeadline = moment()
                        .year(deadline.year)
                        .month(deadline.month - 1)
                        .date(deadline.day)
                        .hour(deadline.hour)
                        .minute(deadline.minute)
                        .second(deadline.second)
                        .millisecond(deadline.microsecond / 1000);
                    let momentNow = moment();
                    let diff = momentDeadline.diff(momentNow);
                    let duration = moment.duration(diff);
                    let days = parseInt(duration.asDays());
                    let hours = parseInt(duration.asHours()) - days * 24;
                    let minutes = parseInt(duration.asMinutes()) - days * 1440 - hours * 60;

                    let ret = '';
                    if (days !== 0)
                        ret += days + 'day ';
                    if (hours !== 0)
                        ret += hours + 'hrs ';
                    if (minutes !== 0)
                        ret += minutes + 'min ';

                    if (ret === '')
                        ret = 'just about now';

                    return ret;
                };
                let deadline = this.props.deadline === null ? "." : deadlineRepr(this.props.deadline);

                return (
                        <tr draggable="true"
                            id={this.props.id}
                            className="goal-search-result"
                            onDragStart={(e) => {
                                e.dataTransfer.setData('goalId', this.props.id);
                            }}>
                            <td style={style} onClick={(e) => {
                                this.props.onDescriptionClick(this.props.id);
                            }}>{description}</td>
                            <td className="red-text" onClick={(e) => {
                                this.props.onDeadlineClick(this.props.id);
                            }}>{deadline}</td>
                            <td className="goal-achievement-status" onClick={(e) => {
                                this.props.onAchievementClick(this.props.id);
                            }}><i className="material-icons">{isAchieved}</i></td>
                        </tr>
                );
            }
        });

        /**
         * @propFunctions: onGoalSelect, onToggleGoalAchievement
         * */
        let GoalSearchView = React.createClass({
            maxDescLength: 15,
            getInitialState: function () {
                return {resultSet: []};
            },
            onRegexInputKeyDown: function (e) {
                let self = this;
                switch (e.keyCode || e.which) {
                    // Enter Key
                    case 13:
                        $.ajax({
                            url: "{% url 'restapi:goal_read_regex' %}",
                            method: 'GET',
                            data: {regex: e.target.value},
                            success: function (response) {
                                let jsonResponse = JSON.parse(response);
                                if (jsonResponse.status === 0) {
                                    self.setState({resultSet: jsonResponse.body});
                                    $(self.refs.resultSetContainer).show();
                                }
                                else if (jsonResponse.status === -1) {
                                    toastr.error(jsonResponse.message);
                                }
                            },
                            error: function (response) {
                                toastr.error('Error searching for goals');
                            }
                        });
                        break;
                    // Escape key
                    case 27:
                        e.preventDefault();
                        $(this.refs.resultSetContainer).hide();
                        break;
                    default:
                        break;
                }
            },
            onToggleGoalAchievement: function (id) {
                let self = this;
                $.ajax({
                    {# Dirty Hack #}
                    url: "{% url 'restapi:goal_toggle_is_achieved' 1729 %}".replace('1729', id),
                    method: 'GET',
                    success: function (response) {
                        let jResponse = JSON.parse(response);
                        if (jResponse.status === 0) {
                            let isAchieved = jResponse.body;
                            // set state
                            let resultSet = self.state.resultSet;
                            resultSet.forEach((v, i) => {
                                if (v.id === id) {
                                    v.is_achieved = isAchieved;
                                }
                            });
                            self.setState({resultSet: resultSet});
                            // call back to parent
                            self.props.onToggleGoalAchievement(id, isAchieved);
                        } else if (jResponse.status === -1) {
                            toastr.error(jResponse.message);
                        }
                    },
                    error: function (response) {
                        toastr.error('Error toggling completion of goal');
                    }
                });
            },
            render: function () {
                let resultSet = this.state.resultSet.map((goal) => {
                    return (
                            <GoalSearchResult
                                    key={goal.id}
                                    id={goal.id}
                                    description={goal.description}
                                    deadline={goal.deadline}
                                    isAchieved={goal.is_achieved}
                                    color={goal.color}

                                    maxDescLength={this.maxDescLength}

                                    onAchievementClick={this.onToggleGoalAchievement}
                                    onDescriptionClick={this.props.onGoalSelect}
                                    onDeadlineClick={this.props.onGoalSelect}/>
                    );
                });
                let resultSetContainerStyle = {display: 'none'};
                return (
                        <div className="goal-search-app z-depth-1">
                            <GoalSearchInput onKeyDown={this.onRegexInputKeyDown}
                                             onDoubleClick={(e) => {
                                                 $(this.refs.resultSetContainer).toggle();
                                             }}/>
                            <div ref="resultSetContainer"
                                 className="goal-search-result-set-container"
                                 style={resultSetContainerStyle}>
                                <table>
                                    <tbody>
                                    {resultSet.length === 0 ? (
                                            <tr className="red-text">
                                                <td className="center align">
                                                    <i className="material-icons">border_bottom</i>
                                                    <i className="material-icons">border_bottom</i>
                                                    <i className="material-icons">border_bottom</i>
                                                </td>
                                            </tr>
                                    ) : resultSet}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                );
            }
        });

        /**
         * @propFunctions: onGoalUpdate, onGoalDelete, onGoalFamilyDeselect
         * */
        let GoalDetailView = React.createClass({
            render: function () {
                let style = this.props.isOpen === true ? {display: 'block'} : {display: 'none'};
                return (
                        <div className="goal-detail-view" ref="entireView"
                             style={style}>
                            <button className="btn white black-text z-depth-0 goal-detail-view-hide-btn"
                                    title="Close"
                                    onClick={(e) => {
                                        $(this.refs.entireView).hide()
                                    }}>
                                <i className="material-icons">close</i></button>
                            <label>Description
                                <textarea className="goal-detail-view-description"
                                          defaultValue={this.props.description === undefined ? '' : this.props.description}
                                          ref="description">
                                </textarea>
                            </label>
                            <label>
                                Deadline: t -> minute, m -> month, u -> microsecond
                                <input className="goal-detail-view-deadline"
                                       ref="deadline"
                                       defaultValue={this.props.deadline === undefined ? '' : DatetimeConverter.format(this.props.deadline)}
                                       onDoubleClick={(e) => {
                                           e.target.value = DatetimeConverter.formatNow()
                                       }}/>
                            </label>
                            <button className="btn-floating blue z-depth-0 goal-detail-view-update-btn"
                                    title="Update"
                                    onClick={(e) => {
                                        let id = this.props.id;
                                        let description = this.refs.description.value;
                                        let deadline = DatetimeConverter.parse(this.refs.deadline.value);
                                        if (deadline !== false) {
                                            this.props.onGoalUpdate(id, description, deadline);
                                        }
                                        else {
                                            toastr.error('Incorrect datetime format, try again');
                                        }
                                    }}>
                                <i className="material-icons">sync</i></button>
                            <button className="btn-floating black z-depth-0 goal-detail-view-deselect-btn"
                                    title="Remove from canvas"
                                    onClick={(e) => {
                                        this.props.onGoalFamilyDeselect(this.props.id)
                                    }}>
                                <i className="material-icons">vertical_align_bottom</i></button>
                            <button className="btn-floating red z-depth-0 goal-detail-view-delete-btn"
                                    title="Delete"
                                    onClick={(e) => {
                                        this.props.onGoalDelete(this.props.id);
                                    }}>
                                <i className="material-icons">delete</i></button>
                        </div>
                );
            },
            componentDidUpdate: function () {
                this.refs.description.value = this.props.description === undefined ? '' : this.props.description;
                this.refs.deadline.value = this.props.deadline === undefined ? '' : DatetimeConverter.format(this.props.deadline);
            },
        });

        /**
         * @propFunctions: onGoalCreate
         * */
        let GoalCreateView = React.createClass({
            render: function () {
                let style = this.props.isOpen === true ? {display: 'block'} : {display: 'none'};
                return (
                        <div className="create-goal-view" ref="entireView" style={style}>
                            <button className="btn white black-text z-depth-0 create-goal-view-hide-btn"
                                    title="Create"
                                    onClick={(e) => {
                                        $(this.refs.entireView).hide()
                                    }}>
                                <i className="material-icons">close</i></button>
                            <label>Description
                                <textarea ref="description" className="create-goal-view-description"></textarea>
                            </label>
                            <label>Deadline: Deadline: t -> minute, m -> month, u ->microsecond
                                <input ref="deadline" className="create-goal-view-deadline"
                                       onDoubleClick={(e) => {
                                           e.target.value = DatetimeConverter.formatNow()
                                       }}/>
                            </label>
                            <button className="btn btn-large white black-text z-depth-0 create-goal-view-submit-btn"
                                    title="Submit"
                                    onClick={(e) => {
                                        let description = this.refs.description.value;
                                        let deadline = DatetimeConverter.parse(this.refs.deadline.value);
                                        if (deadline !== false) {
                                            this.props.onGoalCreate(description, deadline);
                                        }
                                        else {
                                            toastr.error('Incorrect datetime format, try again');
                                        }
                                    }}>
                                <i className="material-icons">send</i></button>
                        </div>

                );
            }
        });

        // todo : prevent change of state from external agents like drop
        /**
         * @propFunctions:
         * onGoalDrop,
         * onEmptySpaceClick,
         * onGoalSelect,
         * onRelationSelect,
         * onDoubleClick,
         * onGoalDoubleClick,
         * onEdgeDoubleClick,
         * onEmptySpaceDoubleClick,
         * onGoalContext,
         * onRelationContext,
         * onGoalShowPopup,
         * onTwoGoalsConsecutiveDoubleClick,
         * */
        let GoalCanvasWrapper = React.createClass({
            prevSocietyString: undefined,
            getDefaultProps: function () {
                return {
                    wrappingDivId: 'goal-canvas-wrapper',
                    graphSettings: {
                        MAX_LABEL_LENGTH: 15,
                        colors: {
                            UN_ACHIEVED: {
                                background: 'pink',
                                border: 'purple'
                            },
                            ACHIEVED: {
                                background: 'lightgreen',
                                border: 'green'
                            },
                            MARKED: {
                                background: 'orange',
                                border: 'red'
                            }
                        },
                        visOptions: {
                            nodes: {
                                shape: 'dot',
                                borderWidth: 5,
                                size: 10,
                                font: {size: 15, color: 'black', background: 'white', face: 'Roboto'}
                            },
                            layout: {
                                hierarchical: {
                                    sortMethod: "directed"
                                }
                            },
                            interaction: {
                                hover: true,
                                navigationButtons: true
                            }
                        }
                    },
                };
            },

            // graph fields & methods
            graphNodeDataSet: undefined,
            graphEdgeDataSet: undefined,
            getNodeSet: function (society) {
                const self = this;
                let array = [];
                society.forEach((family, fi) => {
                    family.forEach((goal, gi) => {
                        let color;
                        if (goal.is_achieved === true) {
                            color = self.props.graphSettings.colors.ACHIEVED;
                        }
                        else {
                            color = self.props.graphSettings.colors.UN_ACHIEVED;
                        }
                        array.push({
                            id: goal.id,
                            color: color,
                            label: truncate(goal.description, self.props.graphSettings.MAX_LABEL_LENGTH),
                            title: goal.description
                        });
                    });
                });
                return array;
            },
            getEdgeSet: function (society) {
                let array = [];
                society.forEach((family, fi) => {
                    family.forEach((goal, gi) => {
                        goal.child_ids.forEach((child, ci) => {
                            array.push({
                                from: goal.id,
                                to: child,
                                arrows: 'to'
                            });
                        })
                    });
                });
                return array;
            },

            render: function () {
                return (<div>
                            <div id={this.props.wrappingDivId}
                                 onDrop={(e) => {
                                     this.props.onGoalDrop(e.dataTransfer.getData('goalId'));
                                 }}
                                 onDragOver={(e) => {
                                     e.preventDefault();
                                 }}>
                            </div>
                        </div>
                );
            },
            componentDidMount: function () {
                let canvasDiv = document.getElementById(this.props.wrappingDivId);
                // store node and edge vis data sets for future use
                let nds = this.graphNodeDataSet = new vis.DataSet(this.getNodeSet(this.props.society));
                let eds = this.graphEdgeDataSet = new vis.DataSet(this.getEdgeSet(this.props.society));
                let data = {
                    nodes: nds,
                    edges: eds,
                };
                let options = this.props.graphSettings.visOptions;
                let graph = new vis.Network(canvasDiv, data, options);

                // listeners
                let self = this;
                let NewEdgeMaker = {
                    fromId: undefined,
                    toId: undefined,
                    fromColor: undefined,
                    reset: function () {
                        this.fromId = undefined;
                        this.toId = undefined;
                        this.fromColor = undefined;
                    },
                    startOrEnd: function (nodeId) {
                        // Start
                        if (this.fromId === undefined && this.toId === undefined) {
                            this.fromId = nodeId;
                            this.fromColor = self.graphNodeDataSet.get(nodeId).color;
                            self.graphNodeDataSet.update({
                                id: NewEdgeMaker.fromId,
                                color: self.props.graphSettings.colors.MARKED
                            });
                        }
                        // End
                        else if (this.fromId !== undefined && this.toId === undefined) {
                            self.graphNodeDataSet.update({
                                id: NewEdgeMaker.fromId,
                                color: NewEdgeMaker.fromColor
                            });
                            this.toId = nodeId;
                            self.props.onTwoGoalsConsecutiveDoubleClick(this.fromId, this.toId);
                            this.reset();
                        }
                    },
                    discardOperation: function () {
                        if (this.fromId !== undefined && this.toId === undefined) {
                            self.graphNodeDataSet.update({
                                id: NewEdgeMaker.fromId,
                                color: NewEdgeMaker.fromColor
                            });
                            this.reset();
                        }
                    },
                };
                graph.on('click', function (params) {
                    // on empty space
                    if (params.nodes.length === 0 && params.edges.length === 0) {
                        self.props.onEmptySpaceClick();
                        NewEdgeMaker.discardOperation();
                    }
                });
                graph.on('selectNode', function (params) {
                    self.props.onGoalSelect(params.nodes[0]);
                });
                graph.on('selectEdge', function (params) {
                    self.props.onRelationSelect(params.nodes[0]);
                });
                graph.on('doubleClick', function (params) {
                    self.props.onDoubleClick();
                    // On node
                    if (params.nodes.length === 1) {
                        let nodeId = params.nodes[0];
                        NewEdgeMaker.startOrEnd(nodeId);
                        self.props.onGoalDoubleClick(nodeId);
                    }
                    // On Edge
                    else if (params.edges.length === 1) {
                        let edge = self.graphEdgeDataSet.get(params.edges[0]);
                        let fromGoalId = edge.from;
                        let toGoalId = edge.to;
                        self.props.onEdgeDoubleClick(fromGoalId, toGoalId);
                    }
                    // On empty space
                    else if (params.nodes.length === 0 && params.edges.length === 0) {
                        self.props.onEmptySpaceDoubleClick();
                    }
                });
                graph.on('oncontext', function (params) {
                    // On node
                    if (params.nodes.length === 1) {
                        self.props.onGoalContext(params.nodes[0]);
                    }
                    // On edge
                    else if (params.edges.length === 1) {
                        self.props.onRelationContext(params.nodes[0]);
                    }
                });
                graph.on('showPopup', function (nodeId) {
                    self.props.onGoalShowPopup(nodeId);
                });
            },
            componentDidUpdate: function () {
                // if previous society's graph is different from this ones then re render whole graph
                if (this.prevSocietyString !== JSON.stringify(this.props.society)) {
                    this.graphNodeDataSet.clear();
                    this.graphNodeDataSet.add(this.getNodeSet(this.props.society));
                    this.graphEdgeDataSet.clear();
                    this.graphEdgeDataSet.add(this.getEdgeSet(this.props.society));
                    this.prevSocietyString = JSON.stringify(this.props.society);
                }
            },
        });

        let GoalGlanceView = React.createClass({
            getInitialState: function () {
                return {
                    society: [],
                    goalDetailView: {
                        id: undefined,
                        description: undefined,
                        deadline: undefined,
                        isAchieved: undefined,
                        isOpen: undefined,
                    },
                    goalCreateView: {
                        isOpen: undefined,
                    },
                };
            },

            // state methods
            // does not validate params
            // WARNING: each state method may change graph before returning
            //          most probably you don't want to use a state method in a loop or in consecutive repetition
            // todo : use this.setState((prevState, props) => ({});
            s_pointToGoalInSociety: function (goalId) {
                let answer = [false, -1, -1];
                // todo : actually all such forEach loops
                // little redundant
                // check continues even after finding the goal
                // but clean code
                // anyways society wont be so big to cause any real change
                this.state.society.forEach((family, fi) => {
                    family.forEach((goal, gi) => {
                        if (goal.id === goalId) {
                            answer = [true, fi, gi];
                        }
                    });
                });
                return answer;
            },
            s_setSocietyToFamily: function (family) {
                let state = this.state;
                state.society = [family];
                this.setState(state);
            },
            s_addFamily: function (family) {
                let state = this.state;
                state.society.push(family);
                this.setState(state);
            },
            s_updateGoalInSociety: function (goalId, goal) {
                let goalIndex = this.s_pointToGoalInSociety(goalId);
                if (goalIndex[0]) {
                    let state = this.state;
                    state.society[goalIndex[1]][goalIndex[2]] = goal;
                    this.setState(state);
                }
            },
            s_setGoalAchievement: function (goalId, isAchieved) {
                let goalPos = this.s_pointToGoalInSociety(goalId);
                if (goalPos[0]) {
                    let state = this.state;
                    state.society[goalPos[1]][goalPos[2]].is_achieved = isAchieved;
                    this.setState(state);
                }
            },
            s_removeFamilyIfExists: function (goalId) {
                let goalPos = this.s_pointToGoalInSociety(goalId);
                if (goalPos[0]) {
                    let state = this.state;
                    state.society.splice(goalPos[1], 1);
                    this.setState(state);
                }
            },
            s_makeRelation: function (parentId, childId, newFamily) {
                let state = this.state;
                let removeFamilyIfExists = function (society, goalId) {
                    let familyIndex = -1;
                    society.forEach((family, fi) => {
                        family.forEach((goal, gi) => {
                            if (goal.id === goalId) {
                                familyIndex = fi;
                            }
                        });
                    });
                    if (familyIndex > -1)
                        society.splice(familyIndex, 1);
                };
                removeFamilyIfExists(state.society, parentId);
                removeFamilyIfExists(state.society, childId);
                state.society.push(newFamily);
                this.setState(state);
            },
            s_breakRelation: function (parentId, childId, setOfNewFamilies) {
                let state = this.state;
                let removeFamilyIfExists = function (society, goalId) {
                    let familyIndex = -1;
                    society.forEach((family, fi) => {
                        family.forEach((goal, gi) => {
                            if (goal.id === goalId) {
                                familyIndex = fi;
                            }
                        });
                    });
                    if (familyIndex > -1)
                        society.splice(familyIndex, 1);
                };
                removeFamilyIfExists(state.society, parentId);
                removeFamilyIfExists(state.society, childId);
                state.society.push(setOfNewFamilies[0]);
                // if by breaking relation the family was split into two
                if (setOfNewFamilies.length === 2) {
                    state.society.push(setOfNewFamilies[1]);
                }
                this.setState(state);
            },
            s_clearSociety: function () {
                let state = this.state;
                state.society = [];
                this.setState(state);
            },
            s_openGoalDetailView: function (goalId) {
                let goalPos = this.s_pointToGoalInSociety(goalId);
                if (goalPos[0]) {
                    let state = this.state;
                    let goalToBeOpened = state.society[goalPos[1]][goalPos[2]];
                    state.goalDetailView.id = goalToBeOpened.id;
                    state.goalDetailView.description = goalToBeOpened.description;
                    state.goalDetailView.deadline = goalToBeOpened.deadline;
                    state.goalDetailView.isAchieved = goalToBeOpened.isAchieved;
                    state.goalDetailView.isOpen = true;
                    this.setState(state);
                }
            },
            s_closeGoalDetailView: function () {
                let state = this.state;
                state.goalDetailView.isOpen = false;
                this.setState(state);
            },
            s_toggleGoalCreateView: function () {
                let state = this.state;
                state.goalCreateView.isOpen = !state.goalCreateView.isOpen;
                this.setState(state);
            },

            // api
            // validate params
            // does ajax calls if needed
            // use state methods for CUD operations
            // preferably use these to state methods
            api_softSelectFamilyOfGoal: function (goalId) {
                goalId = Number(goalId);
                if (!this.s_pointToGoalInSociety(goalId)[0]) {
                    let self = this;
                    $.ajax({
                        {# Dirty hack #}
                        url: "{% url 'restapi:goal_read_family' 1729 %}".replace('1729', String(goalId)),
                        method: 'GET',
                        success: function (response) {
                            let jResponse = JSON.parse(response);
                            if (jResponse.status === 0) {
                                let family = jResponse.body;
                                self.s_addFamily(family);
                            } else if (jResponse.status === -1) {
                                toastr.error(jResponse.message);
                            }
                        },
                        error: function (response) {
                            toastr.error('Error reading family of ' + goalId);
                        }
                    });
                }
            },
            api_hardSelectFamilyOfGoal: function (goalId) {
                goalId = Number(goalId);
                if (!this.s_pointToGoalInSociety(goalId)[0]) {
                    let self = this;
                    $.ajax({
                        {# Dirty hack #}
                        url: "{% url 'restapi:goal_read_family' 1729 %}".replace('1729', String(goalId)),
                        method: 'GET',
                        success: function (response) {
                            let jResponse = JSON.parse(response);
                            if (jResponse.status === 0) {
                                let family = jResponse.body;
                                self.s_setSocietyToFamily(family);
                            } else if (jResponse.status === -1) {
                                toastr.error(jResponse.message);
                            }
                        },
                        error: function (response) {
                            toastr.error('Error reading family of ' + goalId);
                        }
                    });
                }
            },
            api_deselectFamilyOfGoal: function (goalId) {
                goalId = Number(goalId);
                this.s_removeFamilyIfExists(goalId);
                this.s_closeGoalDetailView();
            },
            api_makeRelation: function (parentId, childId) {
                parentId = Number(parentId);
                childId = Number(childId);
                if (this.s_pointToGoalInSociety(parentId)[0] && this.s_pointToGoalInSociety(childId)[0]) {
                    let self = this;
                    $.ajax({
                        url: "{% url 'restapi:goal_add_relation' %}",
                        method: 'POST',
                        data: {
                            parent_id: parentId,
                            child_id: childId
                        },
                        success: function (response) {
                            let jResponse = JSON.parse(response);
                            if (jResponse.status === 0) {
                                let newFamily = jResponse.body;
                                self.s_makeRelation(parentId, childId, newFamily);
                            } else if (jResponse.status === -1) {
                                toastr.error(jResponse.message);
                            }
                        },
                        error: function (response) {
                            toastr.error('Error adding relation');
                        },
                        csrfSafeMethod: function (method) {
                            // these HTTP methods do not require CSRF protection
                            return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
                        },
                        beforeSend: function (xhr, settings) {
                            if (!this.csrfSafeMethod(settings.type) && !this.crossDomain) {
                                xhr.setRequestHeader("X-CSRFToken", Cookies.get('csrftoken'));
                            }
                        }
                    });
                }
            },
            api_breakRelation: function (parentId, childId) {
                parentId = Number(parentId);
                childId = Number(childId);
                if (this.s_pointToGoalInSociety(parentId)[0] && this.s_pointToGoalInSociety(childId)[0]) {
                    let self = this;
                    $.ajax({
                        url: "{% url 'restapi:goal_remove_relation' %}",
                        method: 'POST',
                        data: {
                            parent_id: parentId,
                            child_id: childId
                        },
                        success: function (response) {
                            let jResponse = JSON.parse(response);
                            if (jResponse.status === 0) {
                                let setOfNewFamilies = jResponse.body;
                                self.s_breakRelation(parentId, childId, setOfNewFamilies);
                            } else if (jResponse.status === -1) {
                                toastr.error(jResponse.message);
                            }
                        },
                        error: function (response) {
                            toastr.error('Error removing relation');
                        },
                        csrfSafeMethod: function (method) {
                            // these HTTP methods do not require CSRF protection
                            return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
                        },
                        beforeSend: function (xhr, settings) {
                            if (!this.csrfSafeMethod(settings.type) && !this.crossDomain) {
                                xhr.setRequestHeader("X-CSRFToken", Cookies.get('csrftoken'));
                            }
                        }
                    });
                }
            },
            api_clearCanvas: function () {
                this.s_clearSociety();
            },
            api_createGoal: function (description, deadline) {
                let self = this;
                $.ajax({
                    url: "{% url 'restapi:goal_create' %}",
                    method: 'POST',
                    data: {
                        description: description,
                        deadline: JSON.stringify(deadline),
                    },
                    success: function (response) {
                        let jResponse = JSON.parse(response);
                        if (jResponse.status === 0) {
                            self.s_addFamily([jResponse.body]);
                        } else if (jResponse.status === -1) {
                            toastr.error(jResponse.message);
                        }
                    },
                    error: function (response) {
                        toastr.error('Error creating goal');
                    },
                    csrfSafeMethod: function (method) {
                        // these HTTP methods do not require CSRF protection
                        return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
                    },
                    beforeSend: function (xhr, settings) {
                        if (!this.csrfSafeMethod(settings.type) && !this.crossDomain) {
                            xhr.setRequestHeader("X-CSRFToken", Cookies.get('csrftoken'));
                        }
                    }
                });
            },
            api_updateGoal: function (goalId, description, deadline) {
                goalId = Number(goalId);
                let self = this;
                if (this.s_pointToGoalInSociety(goalId)[0]) {
                    $.ajax({
                        url: "{% url 'restapi:goal_update' %}",
                        method: 'POST',
                        data: {
                            id: goalId,
                            description: description,
                            deadline: JSON.stringify(deadline)
                        },
                        success: function (response) {
                            let jResponse = JSON.parse(response);
                            if (jResponse.status === 0) {
                                self.s_updateGoalInSociety(goalId, jResponse.body);
                                self.s_openGoalDetailView(goalId);
                            } else if (jResponse.status === -1) {
                                toastr.error(jResponse.message);
                            }
                        },
                        error: function (response) {
                            toastr.error('Error updating goal');
                        },
                        csrfSafeMethod: function (method) {
                            // these HTTP methods do not require CSRF protection
                            return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
                        },
                        beforeSend: function (xhr, settings) {
                            if (!this.csrfSafeMethod(settings.type) && !this.crossDomain) {
                                xhr.setRequestHeader("X-CSRFToken", Cookies.get('csrftoken'));
                            }
                        }
                    });
                }
            },
            api_toggleGoalAchievement: function (goalId) {
                goalId = Number(goalId);
                if (this.s_pointToGoalInSociety(goalId)[0]) {
                    let self = this;
                    $.ajax({
                        {# Dirty Hack #}
                        url: "{% url 'restapi:goal_toggle_is_achieved' 1729 %}".replace('1729', goalId),
                        method: 'GET',
                        success: function (response) {
                            let jResponse = JSON.parse(response);
                            if (jResponse.status === 0) {
                                self.s_setGoalAchievement(goalId, jResponse.body);
                            } else if (jResponse.status === -1) {
                                toastr.error(jResponse.message);
                            }
                        },
                        error: function (response) {
                            toastr.error('Error toggling completion of goal');
                        }
                    });
                }
            },
            api_setGoalAchievement: function (goalId, isAchieved) {
                goalId = Number(goalId);
                this.s_setGoalAchievement(goalId, isAchieved);
            },
            api_deleteGoalIfSingle: function (goalId) {
                goalId = Number(goalId);
                let self = this;
                if (this.s_pointToGoalInSociety(goalId)[0]) {
                    $.ajax({
                        url: "{% url 'restapi:goal_delete_if_single' %}",
                        method: 'POST',
                        data: {
                            id: goalId
                        },
                        success: function (response) {
                            let jResponse = JSON.parse(response);
                            if (jResponse.status === 0) {
                                self.s_removeFamilyIfExists(goalId);
                                self.s_closeGoalDetailView();
                            } else if (jResponse.status === -1) {
                                toastr.error(jResponse.message);
                            }
                        },
                        error: function (response) {
                            toastr.error('Error deleting goal');
                        },
                        csrfSafeMethod: function (method) {
                            // these HTTP methods do not require CSRF protection
                            return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
                        },
                        beforeSend: function (xhr, settings) {
                            if (!this.csrfSafeMethod(settings.type) && !this.crossDomain) {
                                xhr.setRequestHeader("X-CSRFToken", Cookies.get('csrftoken'));
                            }
                        }
                    });
                }
            },
            api_openGoalDetailView: function (goalId) {
                goalId = Number(goalId);
                this.s_openGoalDetailView(goalId);
            },
            api_closeGoalDetailView: function () {
                this.s_closeGoalDetailView();
            },
            api_toggleGoalCreateView: function () {
                this.s_toggleGoalCreateView();
            },

            render: function () {
                return (
                        <div>
                            <GoalSearchView onToggleGoalAchievement={this.api_setGoalAchievement}
                                            onGoalSelect={this.api_hardSelectFamilyOfGoal}/>
                            <GoalCanvasWrapper society={this.state.society}
                                               onGoalDrop={this.api_softSelectFamilyOfGoal}
                                               onEmptySpaceClick={this.api_closeGoalDetailView}
                                               onGoalSelect={this.api_openGoalDetailView}
                                               onRelationSelect={() => {
                                               }}
                                               onDoubleClick={() => {
                                               }}
                                               onGoalDoubleClick={(goalId) => {
                                               }}
                                               onEdgeDoubleClick={this.api_breakRelation}
                                               onEmptySpaceDoubleClick={this.api_toggleGoalCreateView}
                                               onGoalContext={this.api_toggleGoalAchievement}
                                               onRelationContext={() => {
                                               }}
                                               onGoalShowPopup={() => {
                                               }}
                                               onTwoGoalsConsecutiveDoubleClick={this.api_makeRelation}/>
                            <button className="btn-floating red z-depth-0 goal-canvas-clear-btn"
                                    title="Clear canvas"
                                    onClick={this.api_clearCanvas}>
                                <i className="material-icons">clear</i></button>
                            <GoalDetailView
                                    id={this.state.goalDetailView.id}
                                    description={this.state.goalDetailView.description}
                                    deadline={this.state.goalDetailView.deadline}
                                    isAchieved={this.state.goalDetailView.is_achieved}
                                    onGoalFamilyDeselect={this.api_deselectFamilyOfGoal}
                                    onGoalUpdate={this.api_updateGoal}
                                    onGoalDelete={this.api_deleteGoalIfSingle}
                                    isOpen={this.state.goalDetailView.isOpen}/>
                            <GoalCreateView
                                    onGoalCreate={this.api_createGoal}
                                    isOpen={this.state.goalCreateView.isOpen}/>
                            <button className="btn-floating green z-depth-0 create-goal-view-toggle-btn"
                                    title="Create a goal"
                                    onClick={this.api_toggleGoalCreateView}>
                                <i className="material-icons">add</i></button>
                        </div>
                );
            },
        });

        ReactDOM.render(<GoalGlanceView/>, document.getElementById('app'));
    </script>
    <div class="container-fluid">
        <div id="app"></div>
    </div>
{% endblock %}
